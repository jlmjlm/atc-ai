A errexit or something to fix up the terminal then emit the error message.
Trigger updates when it's been a while since the last read from atc,
	and then wait indefinitely for a read after the update
	is complete or frame_no was unchanged.
License, readme, INSTALL
Show full end-of-game output when exiting.
atc & atc-ai args (+ usage msg)
flag to skip ahead ('press enter')
+/- to speed-up & slow down (say by 100ms or so)
logfile option
exit after specified #frames, real time, or saved planes
expand tabs, remove trailing spaces
secondary targets for airports
print out (to the log) all planes' courses if get stuck in a loop.
option to use time() for the random seed; option to not pass 'atc' a seed
store revision ID (hash) in the object?
Notice when we get a game over and "Press space".
Figure out exits' directions by letting planes glide if safe.
Handle rogue planes which were shrouded by other planes
	- figure out bearing based on neighboring shadowed squares from 
			last turn and directions which lead directly
			from an exit
	- turn plane in a direction compatible with all poss. bearings
 	- guess based on proximity of exits
Recalculate other planes' courses if they're interfering with
	a new plane's.
Watch memory usage over a long run to check for leaks.
'make dist'
A different "err log" for bugs.
When blocked by a plane, don't match its heading & speed unless also
	 changing alt.
Recalc on a low-fuel ind.  (Just how far can a plane go?)
Get out of a busy loop on SIGINT/SIGTERM.  (Do calc in another thread?)
Err if calc takes too long.
Do I/O in its own thread?
Read cmds from stdin (eg, + and - to incr. & decr. speed)
Have airports/exits in their arrays in their number's position.
Deal with exit clearance better, esp. for border-hugging routes.
Have a mode where the operator "types" slow enough to see.
Keep track of moves taken, so if a plane has "too long" of a route,
we can recalculate routes by starting it off with a short route, and
having others recalculate their routes constrained by it.
-- That won't work for the 1377061305 case, though.  If 'c' calcs its 
	route first ignoring 'b', then 'b' will find it has no first
	moves which aren't adjacent to 'c'.  If 'b' calcs the route
	first, then 'c''s route is too long, because it gets pushed into
	the NW corner by 'b'.  We need to forbid 'c' from matching 'b''s
	velocity, so it can figure out a way to go around it, earlier than
	getting cornered and forcing the matter.
-- Maybe a distance-score penalty for matching the direction & altitude
	of a blocking plane will work better.
Find out why there are "Too many blocking planes" in the self-test.
Do something better than the "getting desperate" stuff in calc_bearing().
Typing delay doesn't work right, because it all happens before there's
	a return to the mainloop to check for new messages from atc.

Interesting seeds:
	1376278304 prop needs to backtrack tick ~1331.

	1376278778 prop needs to backtrack tick 1114.

	1376279911 has a lot cf planes at the start
		At around 1200, a bunch of planes around the same exit
		push one to FL 7.

	1376508107 something goes wrong with the new plane 'D' at the UL
		corner (Fixed)
		Planes "M" and "N" "trap" each other around time 840.
		Hits a prop backtrack at 1021.
	1376515486 similar
		Around time 225, crowding around exit 1 pulls planes to FL 7.
		Hits prop backtrack at t==600.
		Looks awesome around time 3000.
		Plane 'G' blocks plane 'H' from about 3500 on.
		Another blockage around exit 0 stops a plane targeting exit
		1 at ~11450.
		'G' pushes 'H' at about t=27650.
		Three planes together at E. border at ~32390.
		Pretty at 41540.
		Plane 'V' makes a major detour around 58400.
	1376535757 On turn 23 produces a plane at (0, 29, 7)
		[upper right corner].  
		This also has plane 'w' follow blocking place 's' at about
		frame 150 on.
		~800 a plane goes into exit 3 climbing from alt 8 to 9.
		At ~1914, a jet takes off after a prop has committed to
		takeoff on the next turn, forcing a collision.
	1376893850	prop backtrack at tick 117.
	1377061305	plane 'c' runs out of fuel, after flying from
		tick 13831 to 13884.  [fixed]  (Looks like a plane has 50 moves
		of fuel?)

	1377534571 'Killer' - Due to exit blockage, atc-ai crashes
		at tick 3229.  (Fixed)  Now, get an inf. loop at 27070.
		This is because it gets near the exit at alt==5, and
		so can't climb, just circles in the exit's exclusion zone.
		Probably should say can't get within 2 of an exit at
		alt in [6, 8] and can't get within 1 with an alt != 9.
		-- Not enough.  Now at tick 27088 plane 'i' gets inf.
		looped.  Caught at the corner at altitude 5.  Maybe we
		should forbid alt != 9 for distance 2?
	1377644268 'Killer' - Plane 'u' runs out of fuel at
		tick 28306.

	1377809753 'crossover' - Starts with a plane in the NE exit (#3)
	1377811790 'crossover' - At tick 56, plane 'j' is "out of place"
		because in starts out bearing SW and can't turn to the east
		in one tick.  (Fixed.)
