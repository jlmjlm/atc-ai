Organize all these crazy exit codes.
Can we handle "full speed"?  ("-d 0", no unneeded waiting at all):
    "-d 0" fails with "-g airports" with seed 1382293913 at tick 38388
        (6282 saved planes)  [Is this due to the plane list filling up?
        Nope:  Can get past it at "-d 500".]
    [Seems to be fixed, but I changed nothing that I'm aware of.  :\ ]
    "-d 0" also fails with "-g Tic-Tac-Toe" with seed 1382294247 at tick 34322
        (6846 saved planes)
    [Ha ha, but this still breaks right here!]
    [Or not!  It seems to be very finicky.  :( ]
    Now "-d 0" fails at tick 10442 for "-g crosshatch" with seed 1382321877.
    -- And now earlier at tick 9456, with the same build!  -- Hit #9456
        again, very next run.  There was a scroll-up immediately before at
        tick #9455, so something might be wrong about it.  Possibly the
        frame_no got updated, but stuff on the board's display has yet
        to be updated.
    -- Perhaps I should add something to check that the board is "as
        expected", and see if there's any more data from 'atc' which
        will make it go from inconsistent to consistent with some
        very low timeout.
There's still studdering between even-odd ticks.  Maybe some kind of feedback
    to get that converged on a good timeout?
Assert fails tend to leave behind hung 'atc' procs pretty frequently.
    And the ^C handling closer to correct, but still some broken termios stuff
        being left behind.  :/
    Should I have prctl(PR_SET_PDEATHSIG, SIGTERM) on the child's fork so
        that it can clean itself up if 'atc-ai' terminates abruptly?
      -- Doesn't seem to work.  When run on a "-d 0 -g box" until it
             assert_failed, it left behind a wedged "atc" blocked on
             a mutex and unresponsive to signals.
      -- Maybe the exec() resets the death sig, because "atc" is setgid games?
             But I can 'kill' the atc process, and deathsig preservation
             is supposed to exactly match authorization to send a signal to.
License (AGPLv3, I'm thinking).  Author & copyright on all source code,
        and in the usage message.
Should have a 'g' stdin command, which halts the current game and shows a
    game board list, from calling "atc -l", numbered.  Then that number
    will start a game from that board.  This will require handling
    multiple atc children in one atc-ai parent (though only one child
    at a time).
  -- Also a 's' stdin command, to specify the seed to use.
Should figure out how to detect when atc makes termios changes which
        are significant to me.  (Eg, the flag for whether a linefeed ('\n')
        resets the current column back to 0 a-la CR ('\r') or not.)
(Also, what's the macro CTRL in termios.h do?)
Clean up assert vs. errexit.
Perhaps make a "wsfix" target which fixes tabs & trailing spaces.
Is there some kind of "Zen of VT escape sequences" I'm missing?  If I hit
        an esc. seq. I don't know, it'd be nice to just be able to handle
        it by reading it until the sequence terminated and ignore it and
        hope for the best.  But there doesn't seem to be any easy principle
        of what marks seq. termination.
    -- Should go over the terminfo entry for vt100 to make sure I can handle
        any seq which terminfo is going to spit out.
store revision ID (hash) in the object?
Notice when we get a game over and "Press space".
    Specifically: "Hit space for top players list"
Figure out exits' directions by letting planes glide if safe.
Handle rogue planes which were shrouded by other planes
        - figure out bearing based on neighboring shadowed squares from
                        last turn and directions which lead directly
                        from an exit
        - turn plane in a direction compatible with all poss. bearings
        - guess based on proximity of exits
Recalculate other planes' courses if they're interfering with a new plane's.
"make dist"
A different "error log" for bugs.
Planes can go for 50 moves (which is 100 ticks for props).  Re-calc some
        other planes' courses if the new plane requires > 50 moves.
Err if calc takes too long in realtime.
Have airports/exits in their arrays in their number's position.
Deal with exit clearance better.  It's pretty good now, but an arriving plane
        could still in theory be completely path-blocked.
Keep track of moves taken, so if a plane has "too long" of a route, we can
        recalculate routes by starting it off with a short route, and
        having others recalculate their routes constrained by it.
-- Or maybe it'd be better to have all the planes move for one tick,
        minimizing the sum of the distances to the targets, and then do
        that repeatedly.  But maybe it'd be too costly, what with each
        plane having up to 15 possible moves.
Do something better than the "getting desperate" stuff in calc_bearing().
Do we have to strdup(optarg), or is it safe to assume we can use a copy
        after other calls to getopt_long() ?
Should we keep count_malloc and count_free around, even tho there are
        no memleaks, just in case some get introduced?
signalfd() [Linux extension] is a great idea.  It really should be the
        case that anything you can block on can have a wait handle,
        and using fd's for the handles for use in select/poll is unix-y.
        Gets rid of the hacky signal pipe trick.  Don't think I'll be
        able to use it for SIGABRT though, as abort() and assert(false)
        aren't allowed to return.
Nothing to do with atc-ai per se, but atc in some conditions will stomp
        the high score list.  (Hope the new ABRT handling fixes it.)
        -- Nope!  At least not for SIGINT.  Might be abort_hand() [called
           for assert fails and general aborts] versus errexit().  [The
           difference is fuzzy, but generally errexit() is for "didn't
           expect that from the environment & don't know how to deal with it"
           while assert() is for "damn, I screwed something up, internal
           error".]  Seems to be reliably killing the "atc" children,
           but not as resetting the console to "sane".  This is the case
           for SIGINT.  [Which I thought I'd fixed. :( ]
Maybe make an inetd service of this to show it off?  :-)

Thread stuff:
    Start of this on the branch "pthread".
    * Get out of a busy loop on SIGINT/SIGTERM.  (Do calc in another thread?)
    * Do I/O in its own thread?
    * When getting data from ptm, -not- from a timeout, check to see if
        the frame_no has changed.  If it has, move quickly to update_board.
    * Do something with CSP maybe?

Interesting seeds:
        1376515486 'default'
            Hella lot of backtracks:
New record long route: plane 'd' at time 173207 in 69 steps/26 moves.
            I should look into this one in detail.

        1377534571 'Killer'
            Longer than it should be, but not too bad:
New record long route: plane 'b' at time 9478 in 42 steps/40 moves.

        1377644268 'Killer'
New record long route: plane 'g' at time 11850 in 44 steps/42 moves.

        1377930389 'Killer' - runs on forever (or at least to 367536,
                which takes 10h24m at 10 fps [or 47m at 200 fps]).
New record long route: plane 'r' at time 292657 in 68 steps/42 moves.
    -- That's a lot of backtracks!

        1378445708 'airports'
            Useful for the 'v5' airport and the plane ID 'v' taking off
            from it at tick 13939.  (Otherwise seems pedestrian.)

        1380348787 'game_4'
                gives a failed assert at time 2336.  Looks like another
                previously unencountered esc. sequence.  Or two!
                [Esc 7] and [Esc 8 015 012] (Huh?  Don't think I've ever
                had one go into ctrl chars.  Maybe [Esc 8] is the entire
                seq.?  Looks like it:  015==\r and 012==\n, so that's
                just a CR LF.)  [Esc 8] is "restore cursor [position]".
                [Esc 7] is "save cursor [position]".
                --  Dangerously long records:  (Though it gets to tick
                        432580 just fine!)
                   New record long route: plane 'D' at time 9373 in 99 steps.
                        -- This is due to excessive backtracking.
                   New record long route: plane 'm' at time 88231 in 43 steps.
                        This is from getting pushed west:
                        m 88241: (1, 8, 9) bearing W
                        m 88242: (1, 7, 9) bearing W
                        m 88243: (1, 6, 9) bearing W
                        L 88241: (3, 10, 9) bearing NW
                        L 88242: (2, 9, 9) bearing NW
                        L 88243: (2, 9, 9) bearing NW
                         56789abc
                        0========
                        1   m
                        2     \
                        3      L
                        4
                        Looks like it did what it had to, headed west until
                        'L' turned west, at which point it turned S.  It would
                        be better to turn S or SW sooner, but this is pretty
                        good, and it got 'm' back on track with a cost of 6
                        moves.  It wouldn't've been a record at all except
                        there was also a logjam at the exit point.
                   New record long route: plane 'f' at time 104072 in 47 steps.
                        Looks like exit contention:  There's also planes
                        'B', 'D', and 'E' all headed for the same exit as
                        'f' is.  Only way I see to fix this would be to
                        handle plane re-routing to reorder the planes' arrival
                        to the exit to an order more natural than based on
                        best route to the first arrivals in the airspace.


The 1377644268 fuel exhaustion scenario:
At 22043, plane 'z' targeting (7, 29, 9) has to go back from (5, 11, 9)
to (5, 10, 9), and from there on til (4, 3, 9) at 22056 it's pushed westward.

 123456789abcdef
2
3
4
5          zS
6
7          V
8

Okay.  So, the problem is 'z' never tries to descend.  So, looks like we
should give a bonus for unmatching a blocking plane's altitude.
-- --  Tried, but hit plane 'a' hitting empty at tick 18412.  So, this
doesn't seem to be the way to go.
       -- So, now let's try only applying the "altchange" bonus only
          if we're forced to move away from the target (ie, increase
          our distance).  [And boy, do I use "so" too much.]
       -- Okay, that worked for plane 'a' @ 18412.  And 'z' at 22043+.

What's happening with 'default' seed #1376515486 around tick 193107:
Plotting plane g's course from 193099:(13, 1, 7) to 193147:(0, 29, 9)
        g 193106: (9, 7, 8) bearing S
        g 193107: (9, 8, 9) bearing E
        g 193108: (10, 8, 8) bearing S
        g 193109: (10, 9, 9) bearing E
Etc.
        F 193106: (7, 7, 9) bearing SE
        F 193107: (7, 7, 9) bearing SE
        F 193108: (8, 8, 9) bearing SE
        F 193109: (8, 8, 9) bearing SE
Etc.
So we have:
         456789abcde
        5
        6
        7   F
        8    \
        9   g>
        a    |
        b
        c
Hm.  Is there a good way to encourage the "g"s of the game to stick at
alt. 8 when they go East, so they notice that they can go NW at alt. 7 ?
Maybe a small penalty for matching a plane in two dimensions and d=2 on
the 3rd?  (Probably should make da not count, only dr or dc.)  [Done.]

For the same seed on "-g default", at tick 242641 we have:
Plotting plane d's course from 242633:(17, 28, 7) to 242683:(0, 0, 9)
        d 242641: (9, 21, 9) bearing N
        d 242642: (9, 22, 8) bearing E
        d 242643: (8, 22, 9) bearing N
        d 242644: (8, 23, 8) bearing E
Etc.
        A 242641: (10, 19, 9) bearing NE
        A 242642: (9, 20, 9) bearing NE
        A 242643: (9, 20, 9) bearing NE
        A 242644: (8, 21, 9) bearing NE
Etc.
         789abcdefg (+a)
        6
        7
        8     |
        9   /d>
        a  A
        b
Hmm, this doesn't make much sense.  Why is 'd' turning E at ticks 242642,
242644, and so on?  Shouldn't it turn NE?  It's not blocked by 'A'.  And
there don't seem to be any other planes around to be blocking.  --  Ahh,
it's due to the "matchcourse" penalty.  Turning NE would match courses,
so it turns E instead.

-- All right, the fixes worked for those two.  Now the problems we have
from seed 1376515486 are:
New record long route: plane 'j' at time 125177 in 51 steps.
New record long route: plane 'B' at time 252631 in 107 steps.
[The latter actually crashes, just one space from the exit somehow.]

Let's look at j-125177 (target: (0, 29, 9)):
        j 125188: (2, 12, 9) bearing NE
        j 125189: (1, 11, 9) bearing NW
        j 125190: (1, 10, 9) bearing W
        j 125191: (1, 9, 9) bearing W

        i 125188: (3, 14, 9) bearing NW
        i 125189: (2, 13, 9) bearing NW
        i 125190: (1, 12, 9) bearing NW
        i 125191: (1, 11, 9) bearing W
        i 125192: (1, 10, 9) bearing W
 789abcdef
0=========
1    j\
2      i
3

So, what we want is for 'j' to turn south to get around 'i'.  But as it's
heading W *anyway*, the turn to the SW is a greater distance to the target
than staying straight W.  But, why doesn't the "matchcourse" penalty apply
here?  --  Maybe it'd be better to make the "cleared_exit" flag more exact
(check for d>2 being true for all exits), so that we could have 'j' descend
and get around 'i' that way.
First off, I should build a test with this trajectory, to ensure that
calc_next_move() will send 'j' SW instead of due W because of the
matchcourse penalty.  [Done.  But didn't trigger the bug.]
[Try #1 of this failed: The test plane *does* turn SW, not keep going W.
This was because we weren't populating the op_course "isjet" field. :( ]
[Hey, note at tick #59939 of this seed, plane 'r' does a pentipule backtrack!
{Sure enough, it works! :-) }]

Now it shows: "New record long route: plane 'd' at time 173207 in 69 steps."
When the plane's path actually only took < 30 steps.  It's because
it did a *lot* of backtracking, and backtracks don't decrement 'step'
(tho they probably should).  Or maybe "step numbers" should be kept
for both with and w/o backtracks.
