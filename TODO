Organize all these crazy exit codes.
Don't log all the courses.  Instead, log all current planes' courses on an
	error or an inability to plot a safe course.
Trigger updates when it's been a while since the last read from atc,
	and then wait indefinitely for a read after the update
	is complete or frame_no was unchanged.
License, readme, INSTALL
Read cmds from stdin (eg, + and - to incr. & decr. speed)
	-- And proxy ^L thru for a board refresh.
exit after specified #frames, real time, or saved planes
expand tabs, remove trailing spaces
print out (to the log) all planes' courses if get stuck in a loop.
store revision ID (hash) in the object?
Notice when we get a game over and "Press space".
Figure out exits' directions by letting planes glide if safe.
Handle rogue planes which were shrouded by other planes
	- figure out bearing based on neighboring shadowed squares from
			last turn and directions which lead directly
			from an exit
	- turn plane in a direction compatible with all poss. bearings
 	- guess based on proximity of exits
Recalculate other planes' courses if they're interfering with a new plane's.
'make dist'
A different "error log" for bugs.
Planes can go for 50 moves (which is 100 ticks for props).  Re-calc some
	other planes' courses if the new plane requires > 50 moves.
Err if calc takes too long in realtime.
Have airports/exits in their arrays in their number's position.
Deal with exit clearance better.  It's pretty good now, but an arriving plane
	could still in theory be completely path-blocked.
Keep track of moves taken, so if a plane has "too long" of a route, we can
	recalculate routes by starting it off with a short route, and
	having others recalculate their routes constrained by it.
-- That won't work for the 1377061305 case, though.  If 'c' calcs its
	route first ignoring 'b', then 'b' will find it has no first
	moves which aren't adjacent to 'c'.  If 'b' calcs the route
	first, then 'c''s route is too long, because it gets pushed into
	the NW corner by 'b'.  We need to forbid 'c' from matching 'b''s
	velocity, so it can figure out a way to go around it, earlier than
	getting cornered and forcing the matter.
-- Maybe a distance-score penalty for matching the direction & altitude
	of a blocking plane will work better.  (Done, but it seems in
	a fraction of cases a plane can still be pushed away from its
	exit until it reaches the boundary.  Eg, Killer 1377644268
	with plane 'u'.) XXX(remove this a.i.)
-- Or maybe it'd be better to have all the planes move for one tick,
	minimizing the sum of the distances to the targets, and then do
	that repeatedly.  But maybe it'd be too costly, what with each
	plane having up to 15 possible moves.
Do something better than the "getting desperate" stuff in calc_bearing().
Record what the longest routes for jets & props are.
Should we keep count_malloc and count_free around, even tho there are
	no memleaks, just in case some get introduced?  Or remove them?
Should have a --game (-g [or is '-g' already taken?]) option which fwd's
	to "atc", instead of having to do -- -g <game>
Test on different size displays.
Nothing to do with atc-ai per se, but atc in some conditions will stomp
	the high score list.  (Hope the new ABRT handling fixes it.)
	-- Nope!  At least not for SIGINT.  Might be abort_hand() [called
	   for assert fails and general aborts] versus errexit().  [The
	   difference is fuzzy, but generally errexit() is for "didn't
	   expect that from the environment & don't know how to deal with it"
	   while assert() is for "damn, I screwed something up, internal
	   error".]  Seems to be reliably killing the "atc" children,
	   but not as resetting the console to "sane".
Thread stuff:
    Start of this on the branch "pthread".
    * Get out of a busy loop on SIGINT/SIGTERM.  (Do calc in another thread?)
    * Do I/O in its own thread?
    * Have a mode where the operator "types" slow enough to see.
        Tried this without threads, but typing delay doesn't work right,
	because it all happens before there's a return to the mainloop to
	check for new messages from atc.  Maybe instead of threads, the
	procedures in orders.c should just queue up the orders to give
	atc, and mainloop can slowly drain the queue.
    * Back in pthead-land...  When getting data from ptm, -not- from a
	timeout, check to see if the frame_no has changed.  If it has,
	move quickly to update_board

Interesting seeds:
	1376278304 prop needs to backtrack tick ~1331.

	1376278778 prop needs to backtrack tick 1114.

	1376279911 has a lot cf planes at the start
		At around 1200, a bunch of planes around the same exit
		push one to FL 7.

	1376508107 something goes wrong with the new plane 'D' at the UL
		corner (Fixed)
		Planes "M" and "N" "trap" each other around time 840.
		Hits a prop backtrack at 1021.
	1376515486 similar
		Around time 225, crowding around exit 1 pulls planes to FL 7.
		prop backtrack at t==600.
		Looks awesome around time 3000.
		Plane 'G' blocks plane 'H' from about 3500 on.
		Another blockage around exit 0 stops a plane targeting exit
		1 at ~11450.
		'G' pushes 'H' at about t=27650.
		Three planes together at E. border at ~32390.
		Pretty at 41540.
		Plane 'V' makes a major detour around 58400.
	1376535757 On turn 23 produces a plane at (0, 29, 7)
		[upper right corner].
		This also has plane 'w' follow blocking place 's' at about
		frame 150 on.
		~800 a plane goes into exit 3 climbing from alt 8 to 9.
		At ~1914, a jet takes off after a prop has committed to
		takeoff on the next turn, forcing a collision.
	1376893850	prop backtrack at tick 117.
	1377061305	plane 'c' runs out of fuel, after flying from
		tick 13831 to 13884.  [fixed]  (Looks like a plane has 50 moves
		of fuel)

	1377534571 'Killer' - Due to exit blockage, atc-ai crashes
		at tick 3229.  (Fixed)  Now, get an inf. loop at 27070.
		This is because it gets near the exit at alt==5, and
		so can't climb, just circles in the exit's exclusion zone.
		Probably should say can't get within 2 of an exit at
		alt in [6, 8] and can't get within 1 with an alt != 9.
		-- Not enough.  Now at tick 27088 plane 'i' gets inf.
		looped.  Caught at the corner at altitude 5.  Maybe we
		should forbid alt != 9 for distance 2?
	1377644268 'Killer' - Plane 'u' runs out of fuel at
		tick 28306.  Though with the airport secondary targets
		enabled, it switches to plane 'y' at tick 28266.
		Maybe this could be fixed by having a penalty for matching
		a blocking plane's route at a neighboring altitude too?
		Whelp -- with those added, it goes to tick 28240 only, with
		'h' being the plane that fails.  --  And now it's plane 'p'
		at tick 28274.  --  How about reversing the bearing prefs
		each tick?  Will that let these planes figure out how
		to "go around"? - Ha!  That made it worse:  Now plane 'z'
		exhausts fuel at tick 22076.  [Let's look at this in
		detail.  See below.]  And after that stuff below, it
		seems to be fixed!  Made it to 29000 with 6700 saved planes,
		and still going strong.  And ran it until 40367 at 80 ms/frame
		in 54m52s to save 9385 planes.
	1377930389 'Killer' - runs on forever (or at least to 367536,
		which takes 10h24m at 10 fps).
	1378013339 'Killer' - Plane doesn't go to the exit direct sometime
		in 300-320.  It doesn't realize that at the exit, it can't
		be adj. to the approaching plane, just like the approaching
		plane can't be abj. to an exiting airplane.  But, it turned
		out to be the penalty for course matching being a
		disincentive (fixed).

	1377809753 'crossover' - Starts with a plane in the NE exit (#3)
	1377811790 'crossover' - At tick 56, plane 'j' is "out of place"
		because in starts out bearing SW and can't turn to the east
		in one tick.  (Fixed.)

	1378611916 'Tic-Tac-Toe'
		At tick 27, errors with "Found '+ ' where expected to find
		a plane."
	1378613004 'Tic-Tac-Toe'
		Very much similar.  "Found '. ' where expected to find a plane."
		Don't understand how the plane's getting to (9, 1) on the
		display, but stays at (10, 1) on the board -- there's 
		something to write it at (10, 1) at tick 11, but nothing
		alters it for tick 12.  Probably I have to read up on
		vt100 scrolling regions.  The new scoll handling helps,
		as this now gets to frame 129 before fatal confusion.

	1378445708 'airports' -
		* A south-facing airport (#5) gets misrecognized as a
		plane (at FL 5) because of how 'v' is overloaded.  (Fixed)
		* At tick 37, plane 'i' can't go from A0 to A2.  This
		is because taking off from A0 puts it in A2's exclusion
		zone.  (Fixed)
		* And at tick 13939 or so, plane 'v' takes off from the 'v5'
		airport and board.c gets confused again.  (Fixed)
		* Jets seem to be taking a suboptimal route when approaching
		A1 from the west.  --  That's OK, it's just the exclusion zone
		meaning that the incoming plane can either be beside the
		airport at alt==3 or one more square to the south at alt==2,
		either of which is drow==1 and (dcol==0 && dalt == 1) or
		(dcol==1 && dalt == 0) so the exact same distance away, and
		the order we go thru the bearings means we hit these in
		a different order depending on whether we approach from
		WNW or WSW.
		* A bona fide crash (assert failed) at tick 37369.
		This is due to a [Esc M] seq which scrolls the list of
		planes up (see http://www.termsys.demon.co.uk/vtansi.htm ),
		so what atc-ai thinks the board is and what atc thinks
		it is get de-sync'd.  (Looks to be fixed.  Should confirm.)
		* At tick 44207, plane 'j' crashes into terrain, because it
		reaches the alt==1 approach for ap #2 but can't complete the
		turn to bearing 0.  This might be because it flies all the
		way there in A2's exclusion zone at alt==1 and so never gets
		the 'cleared_exit' flag set.  To fix that, hard-exclude
		moving to the ap's primary target from the excl. zone,
		even if cleared_exit is false.  (Done and tested.)


The 1377644268 fuel exhaustion scenario:
At 22043, plane 'z' targeting (7, 29, 9) has to go back from (5, 11, 9)
to (5, 10, 9), and from there on til (4, 3, 9) at 22056 it's pushed westward.

 123456789abcdef
2
3
4
5          zS
6
7          V
8

Okay.  So, the problem is 'z' never tries to descend.  So, looks like we
should give a bonus for unmatching a blocking plane's altitude.
-- --  Tried, but hit plane 'a' hitting empty at tick 18412.  So, this
doesn't seem to be the way to go.
       -- So, now let's try only applying the "altchange" bonus only
	  if we're forced to move away from the target (ie, increase
	  our distance).  [And boy, do I use "so" too much.]
       -- Okay, that worked for plane 'a' @ 18412.  And 'z' at 22043+.
